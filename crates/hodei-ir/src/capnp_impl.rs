//! Cap'n Proto implementation (only included when capnp feature is enabled)

use crate::{
    types::{
        Confidence, FlowId, LineNumber, ColumnNumber, ProjectPath, SourceLocation,
        Severity, Ecosystem, ExtractorId, Provenance, Fact, FactType, FactValue,
        FactValueType, CustomFactType as CustomFactTypeStruct,
    },
    IntermediateRepresentation, ProjectMetadata, AnalysisStats, SchemaVersion,
};
use capnp::serialize_packed;
use std::io::{Cursor, Read, Write};

#[allow(dead_code)]
mod ir_capnp {
    // Generated by build.rs
    include!("generated/ir_capnp.rs");
}

use ir_capnp;

/// Error types for Cap'n Proto operations
#[derive(thiserror::Error, Debug)]
pub enum CapnpError {
    #[error("IO error: {source}")]
    Io {
        #[from]
        source: std::io::Error,
    },

    #[error("Cap'n Proto error: {message}")]
    Capnp {
        #[from]
        source: capnp::Error,
    },

    #[error("Invalid data: {message}")]
    InvalidData { message: String },

    #[error("Conversion error: {message}")]
    Conversion { message: String },
}

/// Serialize a CustomFactType to Cap'n Proto
fn serialize_custom_fact_type(
    custom: &CustomFactTypeStruct,
    writer: &mut capnp::message::Builder<capnp::message::HeapAllocator>,
) -> Result<(), CapnpError> {
    let mut custom_builder = writer.init_root::<ir_capnp::custom_fact_type::Builder>();

    custom_builder.set_discriminant(&custom.discriminant);

    // Serialize the data HashMap as List(KeyValuePair)
    let mut data_builder = custom_builder.init_data(custom.data.len() as u32);

    for (i, (key, value)) in custom.data.iter().enumerate() {
        let mut pair_builder = data_builder.get(i as u32);
        pair_builder.set_key(key);

        // Serialize the FactValue
        let mut value_builder = pair_builder.init_value();
        serialize_fact_value(value, &mut value_builder)?;
    }

    Ok(())
}

/// Deserialize a CustomFactType from Cap'n Proto
fn deserialize_custom_fact_type(
    reader: &ir_capnp::custom_fact_type::Reader,
) -> Result<CustomFactTypeStruct, CapnpError> {
    let discriminant = reader.get_discriminant()?.to_string();

    let data_reader = reader.get_data()?;
    let mut data = std::collections::HashMap::new();

    for pair_reader in data_reader {
        let key = pair_reader.get_key()?.to_string();
        let value = deserialize_fact_value(&pair_reader.get_value()?)?;
        data.insert(key, value);
    }

    Ok(CustomFactTypeStruct {
        discriminant,
        data,
    })
}

/// Serialize a FactValue to Cap'n Proto
fn serialize_fact_value(
    value: &FactValue,
    builder: &mut ir_capnp::fact_value::Builder,
) -> Result<(), CapnpError> {
    match value {
        FactValue::String(s) => {
            builder.set_string(s);
        }
        FactValue::Number(n) => {
            builder.set_number(*n);
        }
        FactValue::Boolean(b) => {
            builder.set_boolean(*b);
        }
        FactValue::Array(arr) => {
            let mut array_builder = builder.init_array(arr.len() as u32);
            for (i, item) in arr.iter().enumerate() {
                let mut item_builder = array_builder.get(i as u32);
                serialize_fact_value(item, &mut item_builder)?;
            }
        }
        FactValue::Object(obj) => {
            let mut object_builder = builder.init_object(obj.len() as u32);
            for (i, (key, value)) in obj.iter().enumerate() {
                let mut pair_builder = object_builder.get(i as u32);
                pair_builder.set_key(key);
                let mut value_builder = pair_builder.init_value();
                serialize_fact_value(value, &mut value_builder)?;
            }
        }
    }

    Ok(())
}

/// Deserialize a FactValue from Cap'n Proto
fn deserialize_fact_value(
    reader: &ir_capnp::fact_value::Reader,
) -> Result<FactValue, CapnpError> {
    use ir_capnp::fact_value::Union;

    match reader.which() {
        Ok(ir_capnp::fact_value::STRING(s)) => {
            Ok(FactValue::String(s?.to_string()))
        }
        Ok(ir_capnp::fact_value::NUMBER(n)) => {
            Ok(FactValue::Number(n))
        }
        Ok(ir_capnp::fact_value::BOOLEAN(b)) => {
            Ok(FactValue::Boolean(b))
        }
        Ok(ir_capnp::fact_value::ARRAY(arr)) => {
            let arr_reader = arr?;
            let mut result = Vec::with_capacity(arr_reader.len() as usize);

            for item_reader in arr_reader {
                result.push(deserialize_fact_value(&item_reader?)?);
            }

            Ok(FactValue::Array(result))
        }
        Ok(ir_capnp::fact_value::OBJECT(obj)) => {
            let obj_reader = obj?;
            let mut result = std::collections::HashMap::new();

            for pair_reader in obj_reader {
                let key = pair_reader.get_key()?.to_string();
                let value = deserialize_fact_value(&pair_reader.get_value()?)?;
                result.insert(key, value);
            }

            Ok(FactValue::Object(result))
        }
        Err(_) => Err(CapnpError::InvalidData {
            message: "Invalid FactValue type".to_string(),
        }),
    }
}

/// Serialize a FactType to Cap'n Proto
fn serialize_fact_type(
    fact_type: &FactType,
    builder: &mut ir_capnp::fact_type::Builder,
) -> Result<(), CapnpError> {
    match fact_type {
        // Existing variants would be handled here
        FactType::Custom(custom) => {
            let mut custom_builder = builder.init_custom();
            serialize_custom_fact_type(custom, &mut custom_builder.init_root::<capnp::message::Builder<capnp::message::HeapAllocator>>())?;
        }
        // Other variants would be implemented similarly
        _ => {
            // For now, only handle Custom type
            return Err(CapnpError::Conversion {
                message: format!("FactType variant not yet implemented for Cap'n Proto: {:?}", fact_type),
            });
        }
    }

    Ok(())
}

/// Deserialize a FactType from Cap'n Proto
fn deserialize_fact_type(
    reader: &ir_capnp::fact_type::Reader,
) -> Result<FactType, CapnpError> {
    use ir_capnp::fact_type::Union;

    match reader.which() {
        Ok(ir_capnp::fact_type::CUSTOM(custom_reader)) => {
            let custom = deserialize_custom_fact_type(custom_reader)?;
            Ok(FactType::Custom(custom))
        }
        Ok(_) => {
            // Other variants would be implemented similarly
            Err(CapnpError::Conversion {
                message: "Only Custom FactType is currently supported for Cap'n Proto deserialization".to_string(),
            })
        }
        Err(_) => Err(CapnpError::InvalidData {
            message: "Invalid FactType variant".to_string(),
        }),
    }
}

/// Serialize an IntermediateRepresentation to bytes
pub fn serialize_ir_to_bytes(
    ir: &IntermediateRepresentation,
) -> Result<Vec<u8>, CapnpError> {
    let mut message = capnp::message::Builder::new_default();

    // Build the IR structure
    let mut ir_builder = message.init_root::<ir_capnp::intermediate_representation::Builder>();

    // Set analysis ID (simplified for now)
    let id_bytes = ir.analysis_id.as_bytes();
    if id_bytes.len() == 16 {
        ir_builder.set_analysis_id(id_bytes);
    } else {
        return Err(CapnpError::InvalidData {
            message: "Invalid analysis ID length".to_string(),
        });
    }

    // Set timestamp
    ir_builder.set_timestamp(ir.timestamp.timestamp_micros());

    // Set metadata
    let mut metadata_builder = ir_builder.init_metadata();
    metadata_builder.set_name(&ir.metadata.name);
    metadata_builder.set_version(&ir.metadata.version);
    metadata_builder.set_root_path(&ir.metadata.root_path.to_string_lossy());
    metadata_builder.set_language(&ir.metadata.language);
    metadata_builder.set_git_commit(&ir.metadata.git_commit);
    metadata_builder.set_git_branch(&ir.metadata.git_branch);

    // Set stats
    let mut stats_builder = ir_builder.init_stats();
    stats_builder.set_total_facts(ir.stats.total_facts);
    stats_builder.set_duration(ir.stats.duration);

    // Set schema version
    let mut schema_version_builder = ir_builder.init_schema_version();
    schema_version_builder.set_major(ir.schema_version.major);
    schema_version_builder.set_minor(ir.schema_version.minor);

    // Serialize facts
    let mut facts_builder = ir_builder.init_facts(ir.facts.len() as u32);

    for (i, fact) in ir.facts.iter().enumerate() {
        let mut fact_builder = facts_builder.get(i as u32);
        serialize_fact(fact, &mut fact_builder)?;
    }

    // Write to bytes
    let mut bytes = Vec::new();
    serialize_packed::write_message(&mut bytes, &message)
        .map_err(|e| CapnpError::Io { source: e })?;

    Ok(bytes)
}

/// Deserialize an IntermediateRepresentation from bytes
pub fn deserialize_ir_from_bytes(
    bytes: &[u8],
) -> Result<IntermediateRepresentation, CapnpError> {
    let cursor = Cursor::new(bytes);
    let mut message_reader = capnp::serialize_packed::read_message(
        cursor,
        capnp::message::ReaderOptions::new(),
    )
    .map_err(|e| CapnpError::Capnp { source: e })?;

    let ir_reader = message_reader
        .get_root::<ir_capnp::intermediate_representation::Reader>()
        .map_err(|e| CapnpError::Capnp { source: e })?;

    // Deserialize facts
    let facts_reader = ir_reader.get_facts()?;
    let mut facts = Vec::with_capacity(facts_reader.len() as usize);

    for fact_reader in facts_reader {
        facts.push(deserialize_fact(&fact_reader?)?);
    }

    // Build the IR
    let schema_version = SchemaVersion::V33;
    
    Ok(IntermediateRepresentation {
        analysis_id: uuid::Uuid::from_bytes(
            ir_reader.get_analysis_id()?.try_into().map_err(|_| {
                CapnpError::InvalidData {
                    message: "Invalid analysis ID length".to_string(),
                }
            })?,
        ),
        timestamp: chrono::DateTime::from_timestamp_micros(ir_reader.get_timestamp())
            .ok_or_else(|| CapnpError::InvalidData {
                message: "Invalid timestamp".to_string(),
            })?,
        metadata: ProjectMetadata {
            name: ir_reader.get_metadata()?.get_name()?.to_string(),
            version: ir_reader.get_metadata()?.get_version()?.to_string(),
            root_path: std::path::PathBuf::from(
                ir_reader.get_metadata()?.get_root_path()?.to_string(),
            ),
            language: ir_reader.get_metadata()?.get_language()?.to_string(),
            git_commit: ir_reader.get_metadata()?.get_git_commit()?.to_string(),
            git_branch: ir_reader.get_metadata()?.get_git_branch()?.to_string(),
        },
        facts,
        stats: AnalysisStats {
            total_facts: ir_reader.get_stats()?.get_total_facts(),
            extractors_used: vec![], // Would need proper deserialization
            duration: ir_reader.get_stats()?.get_duration(),
        },
        schema_version: format!("{}.{}", ir_reader.get_schema_version()?.get_major(), ir_reader.get_schema_version()?.get_minor()),
    })
}

/// Deserialize a Fact from Cap'n Proto
fn deserialize_fact(
    reader: &ir_capnp::fact::Reader,
) -> Result<Fact, CapnpError> {
    let id_bytes = reader.get_id()?;
    let id = uuid::Uuid::from_slice(id_bytes).map_err(|_| CapnpError::InvalidData {
        message: "Invalid UUID".to_string(),
    })?;

    let fact_type = deserialize_fact_type(&reader.get_fact_type()?)?;

    // For simplicity, create minimal location and provenance
    // In a full implementation, these would be properly deserialized
    Ok(Fact {
        id,
        fact_type,
        location: SourceLocation::new(
            ProjectPath::new(std::path::PathBuf::new()),
            LineNumber::new(1).unwrap(),
            Some(ColumnNumber::new(1).unwrap()),
            LineNumber::new(1).unwrap(),
            Some(ColumnNumber::new(1).unwrap()),
        ),
        provenance: Provenance::new(
            ExtractorId::Custom("capnp".to_string()),
            "1.0.0".to_string(),
            Confidence::MEDIUM,
        ),
    })
}

/// Serialize a Fact to Cap'n Proto
fn serialize_fact(
    fact: &Fact,
    builder: &mut ir_capnp::fact::Builder,
) -> Result<(), CapnpError> {
    builder.set_id(&fact.id.as_bytes());

    // Serialize fact type
    let mut fact_type_builder = builder.init_fact_type();
    serialize_fact_type(&fact.fact_type, &mut fact_type_builder)?;

    // Serialize location (simplified)
    let mut location_builder = builder.init_location();
    let mut file_builder = location_builder.init_file();
    file_builder.set_canonical(&fact.location.file.to_string_lossy());

    let start_line_builder = location_builder.init_start_line();
    start_line_builder.set_value(fact.location.start_line.value());

    let start_column_builder = location_builder.init_start_column();
    start_column_builder.set_value(fact.location.start_column.map(|c| c.value()).unwrap_or(0));

    let end_line_builder = location_builder.init_end_line();
    end_line_builder.set_value(fact.location.end_line.value());

    let end_column_builder = location_builder.init_end_column();
    end_column_builder.set_value(fact.location.end_column.map(|c| c.value()).unwrap_or(0));

    // Serialize provenance
    let mut provenance_builder = builder.init_provenance();
    provenance_builder.set_extractor(&fact.provenance.extractor.name());
    provenance_builder.set_version(&fact.provenance.version);

    let mut confidence_builder = provenance_builder.init_confidence();
    confidence_builder.set_value(fact.provenance.confidence.as_f64());

    provenance_builder.set_extracted_at(fact.provenance.extracted_at.timestamp_micros());

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{CustomFactType as CustomFactTypeStruct, LineNumber, ColumnNumber};
    use std::collections::HashMap;

    #[test]
    fn test_serialize_deserialize_custom_fact_type() {
        // Create a CustomFactType with various data types
        let mut data = HashMap::new();
        data.insert(
            "string_field".to_string(),
            FactValue::String("test_value".to_string()),
        );
        data.insert("number_field".to_string(), FactValue::Number(42.5));
        data.insert("boolean_field".to_string(), FactValue::Boolean(true));

        let custom_fact = CustomFactTypeStruct {
            discriminant: "my-plugin:custom-type".to_string(),
            data,
        };

        // Create a FactType::Custom
        let fact_type = FactType::Custom(custom_fact.clone());

        // Serialize
        let mut message = capnp::message::Builder::new_default();
        let mut fact_type_builder = message.init_root::<ir_capnp::fact_type::Builder>();

        serialize_fact_type(&fact_type, &mut fact_type_builder).unwrap();

        // Deserialize
        let mut bytes = Vec::new();
        capnp::serialize_packed::write_message(&mut bytes, &message).unwrap();

        let mut reader = capnp::serialize_packed::read_message(
            Cursor::new(bytes),
            capnp::message::ReaderOptions::new(),
        )
        .unwrap();

        let fact_type_reader = reader
            .get_root::<ir_capnp::fact_type::Reader>()
            .unwrap();

        let deserialized = deserialize_fact_type(&fact_type_reader).unwrap();

        match deserialized {
            FactType::Custom(deserialized_custom) => {
                assert_eq!(deserialized_custom.discriminant, custom_fact.discriminant);
                assert_eq!(deserialized_custom.data.len(), 3);

                assert!(matches!(
                    deserialized_custom.data.get("string_field"),
                    Some(FactValue::String(s)) if s == "test_value"
                ));
                assert!(matches!(
                    deserialized_custom.data.get("number_field"),
                    Some(FactValue::Number(n)) if *n == 42.5
                ));
                assert!(matches!(
                    deserialized_custom.data.get("boolean_field"),
                    Some(FactValue::Boolean(b)) if *b == true
                ));
            }
            _ => panic!("Expected Custom FactType"),
        }
    }

    #[test]
    fn test_serialize_fact_value_array() {
        let array_value = FactValue::Array(vec![
            FactValue::String("first".to_string()),
            FactValue::Number(2.0),
            FactValue::Boolean(false),
        ]);

        let mut message = capnp::message::Builder::new_default();
        let mut value_builder = message.init_root::<ir_capnp::fact_value::Builder>();

        serialize_fact_value(&array_value, &mut value_builder).unwrap();

        // Serialize to bytes
        let mut bytes = Vec::new();
        capnp::serialize_packed::write_message(&mut bytes, &message).unwrap();

        // Deserialize
        let mut reader = capnp::serialize_packed::read_message(
            Cursor::new(bytes),
            capnp::message::ReaderOptions::new(),
        )
        .unwrap();

        let value_reader = reader.get_root::<ir_capnp::fact_value::Reader>().unwrap();
        let deserialized = deserialize_fact_value(&value_reader).unwrap();

        match deserialized {
            FactValue::Array(arr) => {
                assert_eq!(arr.len(), 3);
                assert!(matches!(
                    arr[0],
                    FactValue::String(ref s) if s == "first"
                ));
                assert!(matches!(arr[1], FactValue::Number(n) if n == 2.0));
                assert!(matches!(arr[2], FactValue::Boolean(false)));
            }
            _ => panic!("Expected Array FactValue"),
        }
    }

    #[test]
    fn test_serialize_fact_value_object() {
        let mut obj_data = HashMap::new();
        obj_data.insert(
            "key1".to_string(),
            FactValue::String("value1".to_string()),
        );
        obj_data.insert("key2".to_string(), FactValue::Number(123.0));

        let object_value = FactValue::Object(obj_data);

        let mut message = capnp::message::Builder::new_default();
        let mut value_builder = message.init_root::<ir_capnp::fact_value::Builder>();

        serialize_fact_value(&object_value, &mut value_builder).unwrap();

        // Serialize to bytes
        let mut bytes = Vec::new();
        capnp::serialize_packed::write_message(&mut bytes, &message).unwrap();

        // Deserialize
        let mut reader = capnp::serialize_packed::read_message(
            Cursor::new(bytes),
            capnp::message::ReaderOptions::new(),
        )
        .unwrap();

        let value_reader = reader.get_root::<ir_capnp::fact_value::Reader>().unwrap();
        let deserialized = deserialize_fact_value(&value_reader).unwrap();

        match deserialized {
            FactValue::Object(obj) => {
                assert_eq!(obj.len(), 2);
                assert!(matches!(
                    obj.get("key1"),
                    Some(FactValue::String(ref s)) if s == "value1"
                ));
                assert!(matches!(
                    obj.get("key2"),
                    Some(FactValue::Number(n)) if n == 123.0
                ));
            }
            _ => panic!("Expected Object FactValue"),
        }
    }
}
