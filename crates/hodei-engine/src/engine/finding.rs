use hodei_ir::{Confidence, SourceLocation};
use serde::{Deserialize, Serialize};
use std::time::SystemTime;

/// A finding generated by a rule evaluation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Finding {
    /// Unique identifier for this finding
    pub id: String,
    /// The rule that generated this finding
    pub rule_name: String,
    /// The message describing the finding
    pub message: String,
    /// Source location where the finding was detected
    pub location: SourceLocation,
    /// Confidence level (0.0 to 1.0)
    pub confidence: Confidence,
    /// Severity level
    pub severity: String,
    /// Metadata associated with the finding
    pub metadata: std::collections::HashMap<String, String>,
    /// When the finding was created
    pub created_at: SystemTime,
}

/// Builder for creating findings with template interpolation
#[derive(Debug, Clone)]
pub struct FindingBuilder {
    rule_name: Option<String>,
    message_template: Option<String>,
    location: Option<SourceLocation>,
    confidence: Option<Confidence>,
    severity: Option<String>,
    metadata: std::collections::HashMap<String, String>,
    fact: Option<hodei_ir::Fact>,
}

impl FindingBuilder {
    /// Create a new finding builder
    pub fn new() -> Self {
        Self {
            rule_name: None,
            message_template: None,
            location: None,
            confidence: None,
            severity: None,
            metadata: std::collections::HashMap::new(),
            fact: None,
        }
    }

    /// Set the rule name
    pub fn rule_name(mut self, name: &str) -> Self {
        self.rule_name = Some(name.to_string());
        self
    }

    /// Set the message template with placeholders like {variable.field}
    pub fn message(mut self, template: &str) -> Self {
        self.message_template = Some(template.to_string());
        self
    }

    /// Set the source location
    pub fn location(mut self, location: SourceLocation) -> Self {
        self.location = Some(location);
        self
    }

    /// Set the confidence level
    pub fn confidence(mut self, confidence: Confidence) -> Self {
        self.confidence = Some(confidence);
        self
    }

    /// Set the severity level
    pub fn severity(mut self, severity: &str) -> Self {
        self.severity = Some(severity.to_string());
        self
    }

    /// Add metadata key-value pair
    pub fn metadata(mut self, key: &str, value: &str) -> Self {
        self.metadata.insert(key.to_string(), value.to_string());
        self
    }

    /// Associate a fact with this finding for template interpolation
    pub fn with_fact(mut self, fact: hodei_ir::Fact) -> Self {
        self.fact = Some(fact);
        self
    }

    /// Build the finding with template interpolation
    pub fn build(mut self) -> Result<Finding, FindingError> {
        // Extract all required fields first
        let rule_name = self.rule_name.take().ok_or(FindingError::MissingField {
            field: "rule_name".to_string(),
        })?;

        let message_template = self
            .message_template
            .take()
            .ok_or(FindingError::MissingField {
                field: "message_template".to_string(),
            })?;

        let location = self.location.take().ok_or(FindingError::MissingField {
            field: "location".to_string(),
        })?;

        let confidence = self.confidence.take().ok_or(FindingError::MissingField {
            field: "confidence".to_string(),
        })?;

        let severity = self.severity.take().ok_or(FindingError::MissingField {
            field: "severity".to_string(),
        })?;

        // Clone metadata for use in interpolation
        let metadata = self.metadata.clone();

        // Interpolate message template
        let message = if let Some(ref fact) = self.fact {
            self.interpolate_template(&message_template, fact, &metadata)?
        } else {
            message_template
        };

        let id = format!("{}-{:?}", rule_name, SystemTime::now());

        Ok(Finding {
            id,
            rule_name,
            message,
            location,
            confidence,
            severity,
            metadata: self.metadata,
            created_at: SystemTime::now(),
        })
    }

    /// Interpolate template placeholders like {variable.field}
    fn interpolate_template(
        &self,
        template: &str,
        fact: &hodei_ir::Fact,
        metadata: &std::collections::HashMap<String, String>,
    ) -> Result<String, FindingError> {
        let re = regex::Regex::new(r"\{([^}]+)\}")
            .map_err(|e| FindingError::TemplateError(format!("Invalid regex: {}", e)))?;

        let mut result = template.to_string();

        for cap in re.captures_iter(template) {
            let placeholder = &cap[0];
            let path_str = &cap[1];

            // Parse and resolve the path
            let value = self
                .resolve_path(path_str, fact, metadata)
                .map_err(|e| FindingError::TemplateError(e))?;

            result = result.replace(placeholder, &value);
        }

        Ok(result)
    }

    /// Resolve a path like "fact.location.file" to its string value
    fn resolve_path(
        &self,
        path: &str,
        fact: &hodei_ir::Fact,
        metadata: &std::collections::HashMap<String, String>,
    ) -> Result<String, String> {
        let segments: Vec<&str> = path.split('.').collect();

        match segments[0] {
            "fact" => {
                if segments.len() == 1 {
                    return Ok(format!("{:?}", fact.fact_type));
                }

                match segments[1] {
                    "type" => Ok(format!("{:?}", fact.fact_type.discriminant())),
                    "confidence" => Ok(format!("{:.2}", fact.provenance.confidence.get())),
                    "id" => Ok(format!("{:?}", fact.id)),
                    "location" => {
                        if segments.len() == 3 {
                            match segments[2] {
                                "file" => Ok(fact.location.file.as_str().to_string()),
                                "start_line" => Ok(fact.location.start_line.get().to_string()),
                                _ => Err(format!("Unknown location field: {}", segments[2])),
                            }
                        } else {
                            Ok(format!("{:?}", fact.location))
                        }
                    }
                    _ => Err(format!("Unknown fact field: {}", segments[1])),
                }
            }
            "metadata" => {
                if segments.len() >= 2 {
                    let key = segments[1];
                    if let Some(value) = metadata.get(key) {
                        Ok(value.clone())
                    } else {
                        Ok("unknown".to_string())
                    }
                } else {
                    Err("Metadata path requires key".to_string())
                }
            }
            _ => Err(format!("Unknown root path: {}", segments[0])),
        }
    }
}

impl Default for FindingBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Error types for finding operations
#[derive(Debug, thiserror::Error)]
pub enum FindingError {
    #[error("Missing required field: {field}")]
    MissingField { field: String },

    #[error("Template interpolation error: {0}")]
    TemplateError(String),
}

#[cfg(test)]
mod tests {
    use super::*;
    use hodei_ir::*;

    fn create_test_source_location() -> SourceLocation {
        SourceLocation::new(
            hodei_ir::ProjectPath::new(std::path::PathBuf::from("test.rs")),
            LineNumber::new(1).unwrap(),
            None,
            LineNumber::new(1).unwrap(),
            None,
        )
    }

    #[test]
    fn test_finding_builder_minimal() {
        let finding = FindingBuilder::new()
            .rule_name("test-rule")
            .message("Test finding")
            .location(create_test_source_location())
            .confidence(Confidence::HIGH)
            .severity("high")
            .build()
            .unwrap();

        assert_eq!(finding.rule_name, "test-rule");
        assert_eq!(finding.message, "Test finding");
        assert_eq!(finding.severity, "high");
        assert_eq!(finding.confidence.get(), 0.9);
    }

    #[test]
    fn test_finding_builder_with_metadata() {
        let finding = FindingBuilder::new()
            .rule_name("security-check")
            .message("Security issue detected")
            .location(create_test_source_location())
            .confidence(Confidence::HIGH)
            .severity("critical")
            .metadata("cwe", "CWE-79")
            .metadata("owasp", "A03:2021")
            .build()
            .unwrap();

        assert_eq!(finding.metadata.get("cwe"), Some(&"CWE-79".to_string()));
        assert_eq!(finding.metadata.get("owasp"), Some(&"A03:2021".to_string()));
    }

    #[test]
    fn test_finding_builder_missing_field() {
        let result = FindingBuilder::new()
            .message("Incomplete finding")
            .location(create_test_source_location())
            .confidence(Confidence::MEDIUM)
            .severity("medium")
            .build();

        assert!(result.is_err());
        if let Err(FindingError::MissingField { field }) = result {
            assert_eq!(field, "rule_name");
        }
    }

    #[test]
    fn test_finding_builder_template_interpolation() {
        // Create a test fact
        let fact = hodei_ir::Fact::new_with_message(
            hodei_ir::FactType::Function {
                name: hodei_ir::FunctionName("test_func".to_string()),
                complexity: 5,
                lines_of_code: 10,
            },
            "Function check".to_string(),
            create_test_source_location(),
            hodei_ir::Provenance::new(
                hodei_ir::ExtractorId::TreeSitter,
                "1.0.0".to_string(),
                Confidence::MEDIUM,
            ),
        );

        let finding = FindingBuilder::new()
            .rule_name("function-check")
            .message("Found {fact.type} with confidence {fact.confidence}")
            .location(create_test_source_location())
            .confidence(Confidence::HIGH)
            .severity("critical")
            .with_fact(fact)
            .build()
            .unwrap();

        assert!(finding.message.contains("Function"));
        assert!(finding.message.contains("0.60"));
    }

    #[test]
    fn test_finding_builder_template_interpolation_with_metadata() {
        // Create a test fact
        let fact = hodei_ir::Fact::new_with_message(
            hodei_ir::FactType::Function {
                name: hodei_ir::FunctionName("test_func".to_string()),
                complexity: 5,
                lines_of_code: 10,
            },
            "Function with metadata".to_string(),
            create_test_source_location(),
            hodei_ir::Provenance::new(
                hodei_ir::ExtractorId::TreeSitter,
                "1.0.0".to_string(),
                Confidence::HIGH,
            ),
        );

        let finding = FindingBuilder::new()
            .rule_name("function-check")
            .message("Type: {fact.type}, File: {fact.location.file}")
            .location(create_test_source_location())
            .confidence(Confidence::HIGH)
            .severity("critical")
            .metadata("test", "value")
            .with_fact(fact)
            .build()
            .unwrap();

        assert!(finding.message.contains("Type: Function"));
        assert!(finding.message.contains("test.rs"));
    }
}
