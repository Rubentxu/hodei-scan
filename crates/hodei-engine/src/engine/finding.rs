use hodei_ir::{Confidence, SourceLocation};
use serde::{Deserialize, Serialize};
use std::time::SystemTime;

/// A finding generated by a rule evaluation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Finding {
    /// Unique identifier for this finding
    pub id: String,
    /// The rule that generated this finding
    pub rule_name: String,
    /// The message describing the finding
    pub message: String,
    /// Source location where the finding was detected
    pub location: SourceLocation,
    /// Confidence level (0.0 to 1.0)
    pub confidence: Confidence,
    /// Severity level
    pub severity: String,
    /// Metadata associated with the finding
    pub metadata: std::collections::HashMap<String, String>,
    /// When the finding was created
    pub created_at: SystemTime,
}

/// Builder for creating findings
#[derive(Debug, Clone)]
pub struct FindingBuilder {
    rule_name: Option<String>,
    message: Option<String>,
    location: Option<SourceLocation>,
    confidence: Option<Confidence>,
    severity: Option<String>,
    metadata: std::collections::HashMap<String, String>,
}

impl FindingBuilder {
    /// Create a new finding builder
    pub fn new() -> Self {
        Self {
            rule_name: None,
            message: None,
            location: None,
            confidence: None,
            severity: None,
            metadata: std::collections::HashMap::new(),
        }
    }

    /// Set the rule name
    pub fn rule_name(mut self, name: &str) -> Self {
        self.rule_name = Some(name.to_string());
        self
    }

    /// Set the finding message
    pub fn message(mut self, msg: &str) -> Self {
        self.message = Some(msg.to_string());
        self
    }

    /// Set the source location
    pub fn location(mut self, location: SourceLocation) -> Self {
        self.location = Some(location);
        self
    }

    /// Set the confidence level
    pub fn confidence(mut self, confidence: Confidence) -> Self {
        self.confidence = Some(confidence);
        self
    }

    /// Set the severity level
    pub fn severity(mut self, severity: &str) -> Self {
        self.severity = Some(severity.to_string());
        self
    }

    /// Add metadata key-value pair
    pub fn metadata(mut self, key: &str, value: &str) -> Self {
        self.metadata.insert(key.to_string(), value.to_string());
        self
    }

    /// Build the finding
    pub fn build(self) -> Result<Finding, FindingError> {
        let rule_name = self.rule_name.ok_or(FindingError::MissingField {
            field: "rule_name".to_string(),
        })?;

        let message = self.message.ok_or(FindingError::MissingField {
            field: "message".to_string(),
        })?;

        let location = self.location.ok_or(FindingError::MissingField {
            field: "location".to_string(),
        })?;

        let confidence = self.confidence.ok_or(FindingError::MissingField {
            field: "confidence".to_string(),
        })?;

        let severity = self.severity.ok_or(FindingError::MissingField {
            field: "severity".to_string(),
        })?;

        let id = format!("{}-{:?}", rule_name, SystemTime::now());

        Ok(Finding {
            id,
            rule_name,
            message,
            location,
            confidence,
            severity,
            metadata: self.metadata,
            created_at: SystemTime::now(),
        })
    }
}

impl Default for FindingBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Error types for finding operations
#[derive(Debug, thiserror::Error)]
pub enum FindingError {
    #[error("Missing required field: {field}")]
    MissingField { field: String },
}

#[cfg(test)]
mod tests {
    use super::*;
    use hodei_ir::*;

    fn create_test_source_location() -> SourceLocation {
        SourceLocation::new(
            ProjectPath::new(std::path::PathBuf::from("test.rs")),
            LineNumber::new(1).unwrap(),
            None,
            LineNumber::new(1).unwrap(),
            None,
        )
    }

    #[test]
    fn test_finding_builder_minimal() {
        let finding = FindingBuilder::new()
            .rule_name("test-rule")
            .message("Test finding")
            .location(create_test_source_location())
            .confidence(Confidence::new(0.9).unwrap())
            .severity("high")
            .build()
            .unwrap();

        assert_eq!(finding.rule_name, "test-rule");
        assert_eq!(finding.message, "Test finding");
        assert_eq!(finding.severity, "high");
        assert_eq!(finding.confidence.get(), 0.9);
    }

    #[test]
    fn test_finding_builder_with_metadata() {
        let finding = FindingBuilder::new()
            .rule_name("security-check")
            .message("Security issue detected")
            .location(create_test_source_location())
            .confidence(Confidence::new(0.95).unwrap())
            .severity("critical")
            .metadata("cwe", "CWE-79")
            .metadata("owasp", "A03:2021")
            .build()
            .unwrap();

        assert_eq!(finding.metadata.get("cwe"), Some(&"CWE-79".to_string()));
        assert_eq!(finding.metadata.get("owasp"), Some(&"A03:2021".to_string()));
    }

    #[test]
    fn test_finding_builder_missing_field() {
        let result = FindingBuilder::new()
            .message("Incomplete finding")
            .location(create_test_source_location())
            .confidence(Confidence::new(0.5).unwrap())
            .severity("medium")
            .build();

        assert!(result.is_err());
        if let Err(FindingError::MissingField { field }) = result {
            assert_eq!(field, "rule_name");
        }
    }
}
